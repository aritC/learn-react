# REACT JS REFRESHER REPO

- index js is always the first file to be executed
- the code isnt run 1 to 1 it is first transformed and then delivered to the browser for rendering
- react and react-dom together make up the react library
- ReactDOM.createRoot() method creates the root element of the webpage where our code is going to be loaded
- index.html is the entry point of the code.
- component in react is just a function. A special function as it returns html code but it is still a simple js function
- instead of the JSX return we can write it in plain JS with React.createElement() method
  - it takes 3 element as argument.
  - first is the element which should be created.
  - second element is the object which sets the attributes of the element.
  - third it the content in btw the opening and closing first element. Also it can be infinite elements and not just 1.
  - if its a html element you can just pass the string like 'div' but incase of custom component you can refer the component directly.
- in past all the files where JSX was used needed the import React from './react' line, but now it is able to process without it.
- we can use spread operator and update part of state keeping the prevState intact but we should remember that react schedules the state updates so in some case directly updating can cause some states to refer to older states. To prevent this from happening we can pass an anonymous function to the setState function which has the prevState as an arg and use spread op on that prevState arg.
- On every state, props or context change the related components are re-evaluated it might or might not be re-rendered based on the difference.
- we can export components using memo like React.memo(<Component/>) which prevents unecessary re-evaluated of components if the props have not change. But when using this we need to keep in mind that we are trading the performance of re-evaluation of component to the performance of comparing old props to new props.
- Since all react components are just functions every time a component is re-evaluated all the things defined inside it are re made so essentially they are new functions which do the same old thing. Hence if we are passing the function as a prop to some component it will also be re-evaluated regardless of if we use React.memo or not since the function passed to it has changed.
- The comparision for change is done using regular comparision operator "===" and hence for a regular state which uses primitive JS types it'll work but for anything other than that the component is re-evaluated.
- To prevent this issue from happening we use "useCallback" hook and pass the function body with its dependencies to it. This ensures that React.memo() is able to do its job.
